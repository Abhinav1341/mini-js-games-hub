<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Neon Defense V3 - Extreme</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js for Sound Effects -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400..900&display=swap');
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0d0c1d;
            color: #d1d5db;
        }
        canvas {
            background-color: #03040c;
            box-shadow: 0 0 20px rgba(0, 255, 255, 0.5);
            border: 2px solid #00ffff;
            border-radius: 8px;
            cursor: crosshair;
        }
        .neon-text {
            text-shadow: 0 0 5px #00ffff, 0 0 10px #00ffff, 0 0 20px #00ffff;
        }
        .neon-button {
            background-color: #00ffff20;
            border: 1px solid #00ffff;
            color: #00ffff;
            transition: all 0.1s;
            box-shadow: 0 0 5px #00ffff;
        }
        .neon-button:hover:not(:disabled) {
            background-color: #00ffff40;
            box-shadow: 0 0 10px #00ffff, 0 0 15px #00ffff;
        }
        .shop-item:hover {
            border-color: #ff00ff;
            box-shadow: 0 0 10px #ff00ff;
        }
        .upgrade-item {
            border-color: #ffaa00;
        }
        .upgrade-item:hover {
            border-color: #fff000;
            box-shadow: 0 0 10px #fff000;
        }
    </style>
</head>
<body class="p-4 flex flex-col items-center min-h-screen">

    <div class="flex flex-col md:flex-row w-full max-w-7xl gap-4">
        
        <!-- Controls & Shop Panel -->
        <div id="control-panel" class="md:w-1/4 w-full p-4 bg-gray-900/50 rounded-lg shadow-xl border border-gray-700">
            <h2 class="text-xl font-bold neon-text mb-4 text-center">CORE SYSTEM</h2>
            
            <!-- Stats -->
            <div class="mb-4 space-y-2 text-sm">
                <p id="stats-health" class="bg-red-900/50 p-2 rounded-md border border-red-700">HP: 20</p>
                <p id="stats-money" class="bg-green-900/50 p-2 rounded-md border border-green-700">CREDITS: 300</p>
                <p id="stats-wave" class="bg-blue-900/50 p-2 rounded-md border border-blue-700">WAVE: 0 / 5</p>
                <p id="stats-score" class="bg-purple-900/50 p-2 rounded-md border border-purple-700">SCORE: 0</p>
                <p id="user-info" class="bg-gray-700/50 p-2 rounded-md text-xs truncate">User ID: Loading...</p>
            </div>

            <!-- Global Upgrades -->
            <h3 class="text-lg font-semibold neon-text mt-6 mb-2 text-center">GLOBAL UPGRADES</h3>
            <div id="global-upgrades" class="space-y-2">
                <!-- Fortify Core - Set data-cost here -->
                <button id="btn-fortify" class="upgrade-item neon-button w-full p-2 text-sm rounded-md disabled:opacity-50 disabled:cursor-not-allowed" data-cost="200">
                    FORTIFY CORE ($200) <span id="fortify-level">(Lvl 0)</span>
                </button>
                <!-- Resource Stream - Set data-cost here -->
                <button id="btn-resource" class="upgrade-item neon-button w-full p-2 text-sm rounded-md disabled:opacity-50 disabled:cursor-not-allowed" data-cost="150">
                    RESOURCE STREAM ($150) <span id="resource-level">(Lvl 1)</span>
                </button>
            </div>

            <!-- Tower Shop -->
            <h3 class="text-lg font-semibold neon-text mt-6 mb-2 text-center">TOWER DEPLOYMENT</h3>
            <div id="shop" class="space-y-2">
                <button onclick="startPlacement('STANDARD')" class="shop-item neon-button w-full p-2 rounded-md" data-cost="50">
                    STANDARD TURRET ($50)
                </button>
                <button onclick="startPlacement('PULSAR')" class="shop-item neon-button w-full p-2 rounded-md" data-cost="75">
                    PULSAR (AOE) ($75)
                </button>
                <button onclick="startPlacement('SHOCK')" class="shop-item neon-button w-full p-2 rounded-md" data-cost="120">
                    SHOCK EMITTER (SLOW) ($120)
                </button>
            </div>

            <!-- Wave & Speed Controls -->
            <div class="mt-6 flex gap-2">
                <button id="btn-start-wave" class="neon-button flex-grow p-3 rounded-md bg-blue-700/50 text-base font-bold">
                    START WAVE <span id="wave-preview">1</span>
                </button>
                <button id="btn-speed" class="neon-button p-3 rounded-md w-1/4 text-base font-bold">
                    1X
                </button>
            </div>

            <!-- Selected Tower Info (Sell Button) -->
            <div id="selected-tower-panel" class="mt-6 p-3 bg-indigo-900/50 rounded-lg border border-indigo-700 hidden">
                <h4 class="font-bold text-base text-indigo-300">Selected Tower: <span id="selected-type"></span></h4>
                <p class="text-xs">Range: <span id="selected-range"></span>, DMG: <span id="selected-damage"></span></p>
                <button id="btn-sell-tower" class="neon-button w-full mt-3 p-2 text-sm rounded-md bg-red-700/50 border-red-500 text-red-300">
                    SELL (75% Refund)
                </button>
            </div>
        </div>

        <!-- Canvas Game Area -->
        <div class="md:w-3/4 w-full flex-grow flex justify-center items-center">
            <canvas id="gameCanvas" width="800" height="600"></canvas>
        </div>

    </div>

    <!-- Game Over/Message Modal -->
    <div id="game-message-modal" class="fixed inset-0 bg-black/80 hidden justify-center items-center z-50">
        <div class="bg-gray-900/95 p-8 rounded-xl border-4 border-red-600 shadow-2xl text-center">
            <h2 id="modal-title" class="text-4xl font-extrabold neon-text text-red-500 mb-4">GAME OVER</h2>
            <p id="modal-text" class="text-lg mb-6">The Core has been breached.</p>
            <p class="text-xl neon-text mb-6">Final Score: <span id="modal-score">0</span></p>
            <p class="text-sm text-gray-400">High Score: <span id="modal-highscore">0</span></p>
            <button onclick="location.reload()" class="neon-button px-6 py-3 rounded-md bg-red-600/50 text-white font-bold">
                RESTART SIMULATION
            </button>
        </div>
    </div>

    <!-- Firebase Imports and Setup -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, collection, query, limit, orderBy } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Firebase Initialization (MANDATORY USE OF GLOBAL VARS)
        const firebaseConfig = typeof __firebase_config !== 'undefined' ? JSON.parse(__firebase_config) : {};
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        let db, auth, userId;
        let highscore = 0;
        let isFirebaseReady = false; 
        
        // Set Firebase logging level to debug
        setLogLevel('debug');

        if (Object.keys(firebaseConfig).length > 0) {
            console.log("Firebase config found. Initializing app.");
            const app = initializeApp(firebaseConfig);
            db = getFirestore(app);
            auth = getAuth(app);

            // Authentication
            onAuthStateChanged(auth, async (user) => {
                if (user) {
                    userId = user.uid;
                    document.getElementById('user-info').textContent = `User ID: ${userId}`;
                    initScoreListener();
                    isFirebaseReady = true; 
                    console.log("User authenticated and Firebase ready.");
                } else if (initialAuthToken) {
                    try {
                        console.log("Attempting sign-in with custom token.");
                        await signInWithCustomToken(auth, initialAuthToken);
                    } catch (error) {
                        console.error("Custom token sign-in failed. Falling back to anonymous.", error);
                        await signInAnonymously(auth);
                    }
                } else {
                    console.log("Signing in anonymously.");
                    // Fallback for environments without a custom token
                    await signInAnonymously(auth);
                }
            });
        } else {
            console.warn("Firebase configuration not available. High scores will not be saved.");
        }

        // Firestore Logic
        function initScoreListener() {
            const scorePath = `/artifacts/${appId}/public/data/highscores`;
            // Order by score descending and take the top one
            const q = query(collection(db, scorePath), orderBy("score", "desc"), limit(1));
            
            onSnapshot(q, (snapshot) => {
                if (!snapshot.empty) {
                    highscore = snapshot.docs[0].data().score;
                    console.log("New High Score loaded:", highscore);
                    // Update global high score on load
                    window.globalHighscore = highscore;
                }
            }, (error) => {
                // Log error without stopping execution
                console.error("Error listening to high score:", error);
            });
        }

        window.saveHighscore = async (newScore) => {
            if (!isFirebaseReady) {
                console.error("Attempted to save high score, but Firebase is not ready.");
                return;
            }
            if (newScore > window.globalHighscore && db && userId) {
                try {
                    const scoreRef = doc(db, `/artifacts/${appId}/public/data/highscores`, userId);
                    await setDoc(scoreRef, {
                        userId: userId,
                        score: newScore,
                        timestamp: Date.now()
                    }, { merge: true });
                    window.globalHighscore = newScore;
                    console.log("High score saved successfully:", newScore);
                } catch (e) {
                    console.error("Error saving high score (Firestore failure):", e);
                }
            } else if (newScore <= window.globalHighscore) {
                console.log(`Score (${newScore}) is not a new high score. Skipping save.`);
            }
        };

        window.globalHighscore = 0; // Initialize global variable for use in game logic
    </script>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const synth = new Tone.PolySynth(Tone.Synth, {
            oscillator: { type: 'sine' },
            envelope: { release: 0.1 }
        }).toDestination();

        // --- GAME CONSTANTS & PATH DEFINITION ---
        const CORE_SIZE = 40;
        const TOWER_SIZE = 30;
        const TOWER_COSTS = { STANDARD: 50, PULSAR: 75, SHOCK: 120 };
        const TOWER_COLORS = { STANDARD: '#00ffff', PULSAR: '#ff00ff', SHOCK: '#ffff00' };
        
        // Use a simple, multi-segment path
        const path = [
            { x: 0, y: 100 },
            { x: 300, y: 100 },
            { x: 300, y: 400 },
            { x: 600, y: 400 },
            { x: 600, y: 200 },
            { x: canvas.width, y: 200 } // Exit point
        ];

        // --- GLOBAL STATE ---
        let money = 300;
        let coreHealth = 20;
        let maxCoreHealth = 20; 
        let resourceStreamLevel = 1;
        let wave = 0;
        let score = 0;
        let enemies = [];
        let towers = [];
        let projectiles = [];
        let placingTowerType = null;
        let selectedTower = null; 
        let gameSpeed = 1; 
        let gameInterval = null;
        let waveActive = false;

        // --- ENTITY CLASSES ---

        class Tower {
            constructor(x, y, type) {
                this.x = x;
                this.y = y;
                this.type = type;
                this.lastShot = 0;
                this.cost = TOWER_COSTS[type];
                this.kills = 0;

                switch (type) {
                    case 'STANDARD':
                        this.damage = 10;
                        this.range = 150;
                        this.fireRate = 500; // ms
                        break;
                    case 'PULSAR':
                        this.damage = 15;
                        this.range = 120;
                        this.fireRate = 2000; // Slow rate for AOE
                        this.aoeRadius = 50; // AOE radius
                        break;
                    case 'SHOCK':
                        this.damage = 5;
                        this.range = 180;
                        this.fireRate = 500;
                        this.slowChance = 0.3; // 30% chance to slow
                        break;
                }
            }
            
            // Tower Upgrade Logic
            upgrade() {
                const UPGRADE_COST = 100 + (this.kills * 2); // Dynamic cost
                if (money >= UPGRADE_COST) {
                    money -= UPGRADE_COST;
                    this.damage *= 1.2;
                    this.range *= 1.1;
                    this.fireRate *= 0.9;
                    this.cost += UPGRADE_COST; // Add upgrade cost to total cost for better selling
                    return true;
                }
                return false;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                // Draw Range Indicator when selected
                if (selectedTower === this) {
                    ctx.beginPath();
                    ctx.arc(0, 0, this.range, 0, Math.PI * 2);
                    ctx.strokeStyle = '#ffff00';
                    ctx.fillStyle = 'rgba(255, 255, 0, 0.05)';
                    ctx.lineWidth = 2;
                    ctx.stroke();
                    ctx.fill();
                }

                // Draw Tower Body
                ctx.beginPath();
                ctx.arc(0, 0, TOWER_SIZE / 2, 0, Math.PI * 2);
                ctx.fillStyle = TOWER_COLORS[this.type] + '40';
                ctx.fill();
                ctx.strokeStyle = TOWER_COLORS[this.type];
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw core indicator
                ctx.beginPath();
                ctx.arc(0, 0, TOWER_SIZE / 4, 0, Math.PI * 2);
                ctx.fillStyle = TOWER_COLORS[this.type];
                ctx.fill();

                ctx.restore();
            }

            update(currentTime) {
                if (currentTime - this.lastShot > this.fireRate / gameSpeed) { 
                    const target = enemies.find(e => this.isInRange(e));
                    if (target) {
                        this.fire(target);
                        this.lastShot = currentTime;
                    }
                }
            }

            isInRange(enemy) {
                const dist = Math.sqrt((this.x - enemy.x) ** 2 + (this.y - enemy.y) ** 2);
                return dist <= this.range;
            }

            fire(target) {
                synth.triggerAttackRelease('C4', '8n'); // Sound effect
                const p = new Projectile(this.x, this.y, target, this.damage, this.type);
                if (this.type === 'PULSAR') {
                    p.aoeRadius = this.aoeRadius;
                } else if (this.type === 'SHOCK') {
                    p.slowChance = this.slowChance;
                }
                projectiles.push(p);
            }
        }

        class Enemy {
            constructor(type) {
                this.type = type;
                this.pathIndex = 0;
                this.x = path[0].x;
                this.y = path[0].y;
                this.isSlowed = false; 
                this.slowTimer = 0;
                this.teleportCooldown = 0; 
                this.isRegenerating = true;

                switch (type) {
                    case 'STANDARD':
                        this.maxHealth = 50;
                        this.speed = 1.0;
                        this.reward = 15;
                        this.color = '#00ff00';
                        this.regenRate = 0;
                        this.isArmored = false;
                        break;
                    case 'FAST': 
                        this.maxHealth = 30;
                        this.speed = 2.0;
                        this.reward = 20;
                        this.color = '#ffaa00';
                        this.regenRate = 0;
                        this.isArmored = false;
                        break;
                    case 'TANK': 
                        this.maxHealth = 200;
                        this.speed = 0.7;
                        this.reward = 30;
                        this.color = '#ff0000';
                        this.regenRate = 0;
                        this.isArmored = false;
                        break;
                    case 'ARMORED_HUSK': // New Armored Husk
                        this.maxHealth = 250;
                        this.speed = 0.5;
                        this.reward = 50;
                        this.color = '#666666'; // Dark Grey for armor
                        this.regenRate = 0;
                        this.isArmored = true; // High resistance to physical
                        break;
                    case 'REGENERATOR': // New Regenerator
                        this.maxHealth = 150;
                        this.speed = 1.0;
                        this.reward = 40;
                        this.color = '#ff00ff'; // Pink/Purple
                        this.regenRate = 1; // 1 HP per frame
                        this.isArmored = false;
                        break;
                    case 'QUANTUM_LEAPER': // New Quantum Leaper
                        this.maxHealth = 80;
                        this.speed = 1.5;
                        this.reward = 35;
                        this.color = '#ffff00'; // Bright Yellow
                        this.teleportCooldown = 150 + Math.random() * 50; // Initial cooldown
                        this.regenRate = 0;
                        this.isArmored = false;
                        break;
                }
                this.health = this.maxHealth;
            }

            draw() {
                ctx.save();
                ctx.translate(this.x, this.y);

                const radius = 10;
                // Draw Body (color indicates type)
                ctx.beginPath();
                ctx.arc(0, 0, radius, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.fill();
                
                // Border/Highlight based on state
                let strokeColor = '#ffffff';
                if (this.isSlowed) strokeColor = '#00ffff';
                if (this.isRegenerating && this.regenRate > 0) strokeColor = '#ff00ff'; // Pink glow when regenerating
                if (this.isArmored) strokeColor = '#aaaaaa';

                ctx.strokeStyle = strokeColor;
                ctx.lineWidth = 2;
                ctx.stroke();

                // Health Bar
                const barWidth = 20;
                const barHeight = 4;
                const healthRatio = this.health / this.maxHealth;
                ctx.fillStyle = '#333';
                ctx.fillRect(-barWidth / 2, -radius - 8, barWidth, barHeight);
                ctx.fillStyle = healthRatio > 0.5 ? '#00ff00' : (healthRatio > 0.2 ? '#ffaa00' : '#ff0000');
                ctx.fillRect(-barWidth / 2, -radius - 8, barWidth * healthRatio, barHeight);

                ctx.restore();
            }

            takeDamage(damage, towerType) {
                let actualDamage = damage;
                
                // TANK / Armored Husk resistance to STANDARD towers
                if (towerType === 'STANDARD') {
                    if (this.type === 'TANK') actualDamage *= 0.5; // 50% resistance
                    if (this.type === 'ARMORED_HUSK') actualDamage *= 0.1; // 90% resistance
                }

                this.health -= actualDamage;
                return this.health <= 0;
            }

            update() {
                // Handle Slow Debuff
                if (this.isSlowed && this.slowTimer > 0) {
                    this.slowTimer -= gameSpeed;
                    this.isRegenerating = false; // Stops regeneration
                } else if (this.isSlowed) {
                    this.isSlowed = false;
                    this.isRegenerating = true; // Resumes regeneration
                } else {
                    this.isRegenerating = true;
                }

                // Handle Regeneration
                if (this.isRegenerating && this.regenRate > 0) {
                    this.health = Math.min(this.maxHealth, this.health + this.regenRate * gameSpeed);
                }

                // Movement speed calculation
                let currentSpeed = this.speed; 
                if (this.isSlowed) {
                    currentSpeed *= 0.5; // 50% slow
                }
                currentSpeed *= gameSpeed; 

                // Quantum Leaper Logic (teleport)
                if (this.type === 'QUANTUM_LEAPER' && waveActive) {
                    this.teleportCooldown -= gameSpeed;
                    if (this.teleportCooldown <= 0) {
                        // Teleport 2 path segments ahead (or 100px)
                        let nextPointIndex = this.pathIndex + 1;
                        let nextPoint = path[nextPointIndex];

                        // Calculate a point 100 pixels along the path after the next point
                        if (nextPoint) {
                            const dx = nextPoint.x - this.x;
                            const dy = nextPoint.y - this.y;
                            const dist = Math.sqrt(dx*dx + dy*dy);
                            
                            // Target jump destination (100 pixels ahead, minimum 1 segment)
                            let jumpDistance = 100; 

                            if (dist > jumpDistance) {
                                // Jump within the current segment
                                const ratio = jumpDistance / dist;
                                this.x += dx * ratio;
                                this.y += dy * ratio;
                            } else {
                                // Jump past the next path point
                                this.pathIndex++;
                                if (this.pathIndex < path.length - 1) {
                                    this.x = path[this.pathIndex].x;
                                    this.y = path[this.pathIndex].y;
                                } else {
                                    // Near exit, skip to end
                                    this.x = path[path.length - 1].x;
                                    this.y = path[path.length - 1].y;
                                }
                            }
                        }

                        this.teleportCooldown = 200 + Math.random() * 50; // Reset cooldown (3.3s to 4.1s)
                    }
                }

                // Standard Movement
                if (this.pathIndex < path.length - 1) {
                    const target = path[this.pathIndex + 1];
                    const dx = target.x - this.x;
                    const dy = target.y - this.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < currentSpeed) {
                        this.x = target.x;
                        this.y = target.y;
                        this.pathIndex++;
                    } else {
                        const ratio = currentSpeed / distance;
                        this.x += dx * ratio;
                        this.y += dy * ratio;
                    }
                } else {
                    // Reached the core
                    coreHealth = Math.max(0, coreHealth - 1);
                    money = Math.max(0, money - 5); 
                    return true; // Indicate it reached the end
                }
                return false;
            }
        }

        class Projectile {
            constructor(x, y, target, damage, towerType) {
                this.x = x;
                this.y = y;
                this.target = target;
                this.damage = damage;
                this.speed = 10;
                this.towerType = towerType; 
                this.color = TOWER_COLORS[towerType];
                this.aoeRadius = 0;
                this.slowChance = 0;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, 3, 0, Math.PI * 2);
                ctx.fillStyle = this.color;
                ctx.shadowColor = this.color;
                ctx.shadowBlur = 5;
                ctx.fill();
                ctx.shadowBlur = 0;
            }

            update() {
                // Check if target is still valid (alive and in enemies array)
                if (!this.target || enemies.indexOf(this.target) === -1) {
                    // Let projectile fly off screen if target is dead, to be cleaned up later.
                    return false; 
                }

                const targetX = this.target.x;
                const targetY = this.target.y;

                const dx = targetX - this.x;
                const dy = targetY - this.y;
                const distance = Math.sqrt(dx * dx + dy * dy);

                if (distance < this.speed * gameSpeed) {
                    return true; // Indicate potential hit
                }

                const ratio = (this.speed * gameSpeed) / distance;
                this.x += dx * ratio;
                this.y += dy * ratio;
                return false;
            }
        }

        // --- GAME LOGIC FUNCTIONS ---

        function drawPath() {
            ctx.strokeStyle = '#3333aa';
            ctx.lineWidth = 20;
            ctx.lineCap = 'round';
            ctx.beginPath();
            ctx.moveTo(path[0].x, path[0].y);
            for (let i = 1; i < path.length; i++) {
                ctx.lineTo(path[i].x, path[i].y);
            }
            ctx.stroke();

            // Draw Core/Exit Point
            const exit = path[path.length - 1];
            ctx.beginPath();
            ctx.arc(exit.x, exit.y, CORE_SIZE / 2, 0, Math.PI * 2);
            ctx.fillStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.fill();
            ctx.strokeStyle = '#ff0000';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Health Text
            ctx.fillStyle = 'white';
            ctx.textAlign = 'center';
            ctx.font = 'bold 14px Orbitron';
            ctx.fillText(coreHealth, exit.x, exit.y + 5);
        }

        function updateUI() {
            document.getElementById('stats-health').innerHTML = `HP: ${coreHealth} / ${maxCoreHealth}`;
            document.getElementById('stats-money').textContent = `CREDITS: ${Math.floor(money)}`;
            document.getElementById('stats-score').textContent = `SCORE: ${score}`;
            document.getElementById('stats-wave').textContent = `WAVE: ${wave} / ${waves.length}`;
            document.getElementById('wave-preview').textContent = waveActive ? '' : (wave + 1);

            // Update Upgrade levels & costs
            const fortifyLevel = maxCoreHealth / 10 - 2;
            const fortifyCost = 200 + fortifyLevel * 100;
            document.getElementById('fortify-level').textContent = `(Lvl ${fortifyLevel})`;
            document.getElementById('btn-fortify').setAttribute('data-cost', fortifyCost);
            document.getElementById('btn-fortify').textContent = `FORTIFY CORE ($${fortifyCost}) Lvl ${fortifyLevel+1}`;
            
            const resourceCost = 150 + (resourceStreamLevel - 1) * 100;
            document.getElementById('resource-level').textContent = `(Lvl ${resourceStreamLevel})`;
            document.getElementById('btn-resource').setAttribute('data-cost', resourceCost);
            document.getElementById('btn-resource').textContent = `RESOURCE STREAM ($${resourceCost}) Lvl ${resourceStreamLevel+1}`;


            // Enable/Disable Shop buttons
            document.querySelectorAll('#shop button').forEach(btn => {
                const cost = parseInt(btn.getAttribute('data-cost'));
                btn.disabled = money < cost || waveActive;
            });
            document.querySelectorAll('#global-upgrades button').forEach(btn => {
                const cost = parseInt(btn.getAttribute('data-cost'));
                btn.disabled = money < cost || waveActive;
            });

            // Update Selected Tower Panel
            if (selectedTower) {
                document.getElementById('selected-tower-panel').classList.remove('hidden');
                document.getElementById('selected-type').textContent = selectedTower.type;
                document.getElementById('selected-range').textContent = Math.floor(selectedTower.range);
                document.getElementById('selected-damage').textContent = Math.floor(selectedTower.damage);
                const refund = Math.floor(selectedTower.cost * 0.75);
                document.getElementById('btn-sell-tower').textContent = `SELL (Refund $${refund})`;
                
                // Add upgrade button logic here
                const UPGRADE_COST = 100 + (selectedTower.kills * 2);
                document.getElementById('btn-sell-tower').innerHTML = `
                    <button id="upgrade-btn" class="neon-button w-full mb-2 p-2 text-sm rounded-md bg-green-700/50 border-green-500 text-green-300 disabled:opacity-50" ${money < UPGRADE_COST ? 'disabled' : ''}>
                        UPGRADE (+$${UPGRADE_COST})
                    </button>
                    <button id="sell-btn" class="neon-button w-full p-2 text-sm rounded-md bg-red-700/50 border-red-500 text-red-300">
                        SELL (Refund $${refund})
                    </button>
                `;
                document.getElementById('sell-btn').addEventListener('click', handleSellTower);
                document.getElementById('upgrade-btn').addEventListener('click', handleTowerUpgrade);
            } else {
                document.getElementById('selected-tower-panel').classList.add('hidden');
            }
        }
        
        // UPGRADE HANDLER
        function handleTowerUpgrade() {
            if (selectedTower && selectedTower.upgrade()) {
                // Upgrade successful
                updateUI();
            }
        }

        function checkProjectileCollision(p, index) {
            if (!p.target || enemies.indexOf(p.target) === -1) {
                // If target is dead or invalid, remove the projectile immediately
                projectiles.splice(index, 1);
                return true;
            }

            const dist = Math.sqrt((p.x - p.target.x) ** 2 + (p.y - p.target.y) ** 2);

            if (dist < 15) { // Hit radius
                let killed = false;

                if (p.towerType === 'PULSAR') {
                    // PULSAR AOE effect 
                    enemies.forEach(aoeEnemy => {
                        const aoeDist = Math.sqrt((p.x - aoeEnemy.x) ** 2 + (p.y - aoeEnemy.y) ** 2);
                        if (aoeDist < p.aoeRadius) {
                            if (aoeEnemy.takeDamage(p.damage, p.towerType)) {
                                const enemyIndex = enemies.indexOf(aoeEnemy);
                                if (enemyIndex !== -1) {
                                    handleEnemyDefeat(aoeEnemy, enemyIndex);
                                    p.target.kills++;
                                }
                            }
                        }
                    });

                } else if (p.towerType === 'SHOCK') {
                    // SHOCK Debuff
                    if (Math.random() < p.slowChance) {
                        p.target.isSlowed = true;
                        p.target.slowTimer = 180; // 3 seconds at 60 FPS
                    }
                    if (p.target.takeDamage(p.damage, p.towerType)) {
                        const enemyIndex = enemies.indexOf(p.target);
                        if (enemyIndex !== -1) {
                            handleEnemyDefeat(p.target, enemyIndex);
                            p.target.kills++;
                            killed = true;
                        }
                    }
                } else {
                    // Standard damage
                    if (p.target.takeDamage(p.damage, p.towerType)) {
                        const enemyIndex = enemies.indexOf(p.target);
                        if (enemyIndex !== -1) {
                            handleEnemyDefeat(p.target, enemyIndex);
                            p.target.kills++;
                            killed = true;
                        }
                    }
                }
                projectiles.splice(index, 1);
                return true;
            }
            return false;
        }

        function handleEnemyDefeat(enemy, index) {
            money += enemy.reward;
            score += enemy.maxHealth; 
            enemies.splice(index, 1);
        }

        // --- CORE FEATURES: WAVES & ENEMIES ---

        // Wave Data including new enemies (Armored Husk, Regenerator, Quantum Leaper)
        const waves = [
            [{ type: 'STANDARD', count: 12, delay: 50 }],
            [{ type: 'STANDARD', count: 10, delay: 40 }, { type: 'FAST', count: 5, delay: 60 }],
            [{ type: 'ARMORED_HUSK', count: 3, delay: 100 }, { type: 'STANDARD', count: 10, delay: 40 }], // Forced specialized defense
            [{ type: 'FAST', count: 20, delay: 25 }, { type: 'QUANTUM_LEAPER', count: 2, delay: 150 }], // Forced reaction time
            [{ type: 'REGENERATOR', count: 5, delay: 80 }, { type: 'FAST', count: 10, delay: 40 }], // Forced slowing
            [{ type: 'STANDARD', count: 15, delay: 40 }, { type: 'ARMORED_HUSK', count: 5, delay: 80 }, { type: 'REGENERATOR', count: 3, delay: 120 }], 
            [{ type: 'QUANTUM_LEAPER', count: 5, delay: 100 }, { type: 'TANK', count: 3, delay: 150 }], 
        ];
        
        let enemiesToSpawn = [];

        function startWave() {
            if (waveActive || wave >= waves.length) return;
            waveActive = true;
            wave++;
            money += 50 * resourceStreamLevel; 
            document.getElementById('btn-start-wave').disabled = true;
            
            const currentWave = waves[wave - 1];
            enemiesToSpawn = [];
            currentWave.forEach(group => {
                for (let i = 0; i < group.count; i++) {
                    enemiesToSpawn.push({ type: group.type, delay: group.delay || 50 });
                }
            });
            
            // Start the spawning process
            spawnEnemy();
        }

        let spawnTimer = 0;
        let spawnDelay = 0;

        function spawnEnemy() {
            // Check if game is not over
            if (coreHealth <= 0) return;

            if (enemiesToSpawn.length > 0) {
                if (spawnTimer <= 0) {
                    const nextEnemy = enemiesToSpawn.shift();
                    enemies.push(new Enemy(nextEnemy.type));
                    spawnDelay = nextEnemy.delay;
                    spawnTimer = spawnDelay;
                } else {
                    spawnTimer -= gameSpeed;
                }
                
                // Keep spawning until queue is empty
                requestAnimationFrame(spawnEnemy); 
            } else {
                // Spawning is complete, now wait for clearing
                checkWaveEnd();
            }
        }

        function checkWaveEnd() {
            if (coreHealth <= 0) return; 

            if (enemiesToSpawn.length === 0 && enemies.length === 0 && waveActive) {
                // Wave cleared
                waveActive = false;
                document.getElementById('btn-start-wave').disabled = false;
                spawnTimer = 0;
                
                if (wave >= waves.length) {
                    gameOver(true); // Victory
                }
            } else if (enemiesToSpawn.length === 0 && waveActive) {
                // Spawning done, but enemies remain on screen. Keep checking.
                setTimeout(checkWaveEnd, 500 / gameSpeed);
            }
        }

        // --- CORE FEATURES: TOWER PLACEMENT & SELL ---

        function isPlacementValid(x, y) {
            const PATH_CLEARANCE = 20; 
            
            for (let i = 0; i < path.length - 1; i++) {
                const p1 = path[i];
                const p2 = path[i + 1];
                const distSq = distToSegmentSq(x, y, p1.x, p1.y, p2.x, p2.y);
                if (distSq < (PATH_CLEARANCE * PATH_CLEARANCE)) {
                    return false; 
                }
            }

            for (const tower of towers) {
                const dist = Math.sqrt((x - tower.x) ** 2 + (y - tower.y) ** 2);
                if (dist < TOWER_SIZE) {
                    return false; 
                }
            }
            
            const exit = path[path.length - 1];
            const distToCore = Math.sqrt((x - exit.x) ** 2 + (y - exit.y) ** 2);
            if (distToCore < CORE_SIZE + TOWER_SIZE) {
                 return false; 
            }

            return true;
        }

        function distToSegmentSq(px, py, x1, y1, x2, y2) {
            const l2 = (x2 - x1) ** 2 + (y2 - y1) ** 2;
            if (l2 === 0) return (px - x1) ** 2 + (py - y1) ** 2;
            let t = ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / l2;
            t = Math.max(0, Math.min(1, t));
            const closestX = x1 + t * (x2 - x1);
            const closestY = y1 + t * (y2 - y1);
            return (px - closestX) ** 2 + (py - closestY) ** 2;
        }


        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            if (placingTowerType) {
                const cost = TOWER_COSTS[placingTowerType];
                if (money >= cost && isPlacementValid(x, y)) {
                    const newTower = new Tower(x, y, placingTowerType);
                    towers.push(newTower);
                    money -= cost;
                    selectedTower = newTower; // Select the newly placed tower
                }
                placingTowerType = null;
                canvas.style.cursor = 'crosshair';
            } else {
                // Select tower for selling
                const clickedTower = towers.find(t => {
                    const dist = Math.sqrt((x - t.x) ** 2 + (y - t.y) ** 2);
                    return dist < TOWER_SIZE / 2;
                });
                selectedTower = clickedTower || null;
            }
            updateUI();
        }

        function handleCanvasMove(e) {
            if (!placingTowerType) return;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // Store current mouse position for drawing range preview
            canvas.mouseX = x;
            canvas.mouseY = y;
            canvas.isValidPlacement = isPlacementValid(x, y);
        }

        function startPlacement(type) {
            placingTowerType = type;
            selectedTower = null;
            canvas.style.cursor = 'none';
        }
        
        // Cancel placement with ESC key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && placingTowerType) {
                placingTowerType = null;
                canvas.style.cursor = 'crosshair';
                updateUI();
            }
        });


        function drawPlacementPreview() {
            if (placingTowerType && canvas.mouseX !== undefined) {
                const x = canvas.mouseX;
                const y = canvas.mouseY;
                const cost = TOWER_COSTS[placingTowerType];
                const range = (new Tower(0, 0, placingTowerType)).range;
                
                let strokeColor = '#ff0000'; 
                if (canvas.isValidPlacement && money >= cost) {
                    strokeColor = '#00ff00'; 
                } else if (canvas.isValidPlacement) {
                    strokeColor = '#ffaa00'; 
                }
                let fillColor = strokeColor.replace('ff', '22').replace('00', '22') + '05';
                
                // 1. Range Circle
                ctx.beginPath();
                ctx.arc(x, y, range, 0, Math.PI * 2);
                ctx.strokeStyle = strokeColor;
                ctx.fillStyle = fillColor;
                ctx.lineWidth = 2;
                ctx.stroke();
                ctx.fill();

                // 2. Tower Symbol
                ctx.beginPath();
                ctx.arc(x, y, TOWER_SIZE / 2, 0, Math.PI * 2);
                ctx.fillStyle = TOWER_COLORS[placingTowerType];
                ctx.fill();
            }
        }
        
        // --- CORE FEATURES: GLOBAL UPGRADES & SELL ---
        
        function handleGlobalUpgrade(type) {
            if (waveActive) return;

            let cost = 0;
            if (type === 'FORTIFY') {
                const fortifyLevel = maxCoreHealth / 10 - 2;
                cost = 200 + fortifyLevel * 100;
                if (money >= cost) {
                    money -= cost;
                    maxCoreHealth += 10;
                    coreHealth += 10; 
                }
            } else if (type === 'RESOURCE') {
                cost = 150 + (resourceStreamLevel - 1) * 100;
                if (money >= cost) {
                    money -= cost;
                    resourceStreamLevel++;
                }
            }
            updateUI();
        }
        
        function handleSellTower() {
            if (!selectedTower) return;
            const refund = Math.floor(selectedTower.cost * 0.75);
            money += refund;
            const index = towers.indexOf(selectedTower);
            if (index > -1) {
                towers.splice(index, 1);
            }
            selectedTower = null;
            updateUI();
        }

        // --- GAME LOOP ---

        let lastTime = 0;
        function gameLoop(currentTime) {
            // CRASH PROTECTION: Wrap the core logic in try...catch to prevent mid-wave freezes
            try {
                if (!lastTime) lastTime = currentTime;
                let deltaTime = 1000 / 60; 
                
                // 1. Clear Canvas
                ctx.clearRect(0, 0, canvas.width, canvas.height);

                // 2. Draw Path & Core
                drawPath();

                // 3. Update & Draw Towers
                towers.forEach(t => {
                    t.update(currentTime);
                    t.draw();
                });

                // 4. Update & Draw Enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (enemy.update()) {
                        enemies.splice(i, 1); // Enemy reached the core
                    } else {
                        enemy.draw();
                    }
                }
                
                // 5. Update & Draw Projectiles
                for (let i = projectiles.length - 1; i >= 0; i--) {
                    const p = projectiles[i];
                    if (p.update()) {
                        // Projectile reached target area
                        checkProjectileCollision(p, i);
                    } else {
                        p.draw();
                    }
                }

                // 6. Draw Placement Preview
                drawPlacementPreview();
                
                // 7. Draw Game State Message
                drawGameStateMessage();

                // 8. Check Game State
                if (coreHealth <= 0) {
                    cancelAnimationFrame(gameInterval);
                    gameOver(false);
                    return;
                }
                
                if (!waveActive && enemies.length > 0) {
                    checkWaveEnd();
                }

                updateUI();
                
            } catch (error) {
                // Log error but force loop continuation
                console.error("Critical game logic error, but forcing next frame:", error);
            }

            gameInterval = requestAnimationFrame(gameLoop);
        }
        
        function drawGameStateMessage() {
            // Determine border color based on wave state (Visual Debug/Clarity)
            let borderColor = '#00ffff'; 
            let message = '';
            
            if (waveActive) {
                if (enemiesToSpawn.length > 0) {
                    // Active Spawning
                    borderColor = '#ff00ff'; // Neon Pink
                    message = `SPAWNING... (${enemiesToSpawn.length} left)`;
                } else if (enemies.length > 0) {
                    // Clearing (Spawning complete, enemies remain)
                    borderColor = '#00ff00'; // Neon Green
                    message = `CLEARING - ${enemies.length} REMAINING`;
                }
            } else {
                // Intermission
                borderColor = '#00ffff'; // Neon Blue
                message = `WAVE ${wave + 1} READY`;
            }

            // Update canvas border
            canvas.style.borderColor = borderColor;
            canvas.style.boxShadow = `0 0 10px ${borderColor}`;

            // Draw text over canvas
            if (message && !placingTowerType) {
                ctx.save();
                ctx.textAlign = 'center';
                ctx.font = 'bold 24px Orbitron';
                ctx.fillStyle = borderColor;
                ctx.shadowColor = borderColor;
                ctx.shadowBlur = 10;
                
                ctx.fillText(message, canvas.width / 2, 50);
                
                ctx.restore();
            }
        }


        function gameOver(isVictory) {
            const modal = document.getElementById('game-message-modal');
            document.getElementById('modal-score').textContent = score;
            document.getElementById('modal-highscore').textContent = window.globalHighscore;
            
            if (isVictory) {
                document.getElementById('modal-title').textContent = "VICTORY ACHIEVED!";
                document.getElementById('modal-text').textContent = "All enemy waves have been neutralized. Well done, Commander.";
                modal.querySelector('.border-4').classList.replace('border-red-600', 'border-green-600');
                modal.querySelector('.neon-text').classList.replace('text-red-500', 'text-green-500');
            }
            
            modal.classList.remove('hidden');
            modal.classList.add('flex');
            
            window.saveHighscore(score);
        }

        // --- EVENT LISTENERS ---
        canvas.addEventListener('click', handleCanvasClick);
        canvas.addEventListener('mousemove', handleCanvasMove);
        document.getElementById('btn-start-wave').addEventListener('click', startWave);
        
        // Event listeners for Global Upgrades
        document.getElementById('btn-fortify').addEventListener('click', () => handleGlobalUpgrade('FORTIFY'));
        document.getElementById('btn-resource').addEventListener('click', () => handleGlobalUpgrade('RESOURCE'));
        
        // Fast Forward Toggle
        document.getElementById('btn-speed').addEventListener('click', () => {
            if (gameSpeed === 1) {
                gameSpeed = 2;
                document.getElementById('btn-speed').textContent = '2X';
            } else {
                gameSpeed = 1;
                document.getElementById('btn-speed').textContent = '1X';
            }
        });

        // Initialize and Start
        window.onload = function () {
            updateUI();
            gameInterval = requestAnimationFrame(gameLoop);
        }
    </script>
</body>
</html>
